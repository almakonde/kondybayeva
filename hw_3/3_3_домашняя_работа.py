# -*- coding: utf-8 -*-
"""3_3_Домашняя_работа.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/187J5ss7AoE9nnskr1CBLwx-EMDFmwIc1

## Задача 1. Собачий возраст.

**Условие.** Считается, что один год, прожитый собакой, эквивалентен семи человеческим годам. При этом зачастую не учитывается, что собаки становятся
абсолютно взрослыми уже к двум годам. Таким образом, многие предпочитают каждый из первых двух лет жизни собаки приравнивать к 10,5 года человеческой жизни, а все последующие – к четырем.
Напишите программу, которая будет переводить человеческий возраст в  собачий с  учетом указанной выше логики. Убедитесь, что программа
корректно работает при пересчете возраста собаки меньше и больше двух лет. Также программа должна выводить сообщение об ошибке, если пользователь ввел отрицательное число, либо не числовое значение.
"""

#Напишите свое решение

def human_to_dog_age(human_age):
    if human_age < 0:
        return "Ошибка: Возраст не может быть отрицательным"
    elif human_age <= 2*10.5:
        dog_age = human_age /10.5
    else:
        dog_age = (human_age)/10.5 + (human_age - (2*10.5)) / 4

    return f"Собачий возраст: {dog_age} лет"

try:
    human_age = float(input("Введите человеческий возраст: "))
    result = human_to_dog_age(human_age)
    print(result)
except ValueError:
    print("Ошибка: Введите числовое значение")

"""## Задача 2. Какого цвета клетка?

**Условие.** Клетки на шахматной доске идентифицируются буквой и цифрой. Буква определяет положение клетки по горизонтали, а цифра – по вертикали, как показано на рисунке.

![image.png](data:image/png;base64,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)

Ваша программа должна запрашивать у пользователя координаты клетки. Используйте условное выражение для определения того, с какой клетки – белой или черной – начинается столбец. Затем при помощи обычной арифметики необходимо определить цвет конкретной клетки. Например, если пользователь ввел a1, программа должна определить, что клетка
с этими координатами черная. Если d5 – белая.
"""

#Напишите свое решение

# Запрос координат клетки у пользователя
coordinates = input("Введите координаты клетки (например, a1): ")

# Извлечение буквы и цифры из введенных координат
letter = coordinates[0].lower()  # Преобразуем букву в нижний регистр, чтобы учесть разные варианты
number = int(coordinates[1])

# Проверка, с какой клетки начинается столбец
if letter in 'aceg':
    start_with_white = True
else:
    start_with_white = False

# Определение цвета клетки с учетом буквы и номера строки
if (start_with_white and number % 2 == 0) or (not start_with_white and number % 2 != 0):
    color = "белая"
else:
    color = "черная"

# Вывод результата
print(f"Клетка {coordinates} - {color}.")

"""**Условие.** Напишите программу, запрашивающую у пользователя его имя. В ответ
на ввод на экране должно появиться приветствие с обращением по имени,
введенному с клавиатуры ранее.

"""

#Напишите свое решение
# Запрос имени у пользователя
name = input("Введите ваше имя: ")

# Вывод приветствия с обращением по имени
print(f"Привет, {name}!")

"""## Задача 3. Игра Fizz-Buzz.

**Условие.** Fizz-Buzz  – это известная игра, помогающая детям освоить в  игровой форме правила деления. Участники садятся в круг, чтобы игра теоретически могла продолжаться бесконечно. Первый игрок говорит «Один» и передает ход тому, кто слева. Каждый следующий игрок должен мысленно прибавить к предыдущему числу единицу и произнести либо его, либо одно из ключевых слов: Fizz, если число без остатка делится на три, или Buzz, если на пять. Если соблюдаются оба этих условия, он произносит Fizz-Buzz. Игрок, не сумевший сказать правильное слово, выбывает из игры. Последний оставшийся игрок признается победителем.
Разработайте программу, реализующую алгоритм игры Fizz-Buzz применительно к  первым 100 числам. Каждый следующий ответ должен отображаться на новой строке.
"""

#Напишите свое решение
for number in range(1, 101):
    output = ""
    if number % 3 == 0:
        output += "Fizz"
    if number % 5 == 0:
        output += "Buzz"

    if not output:
        output = number

    print(output)

"""## Задача 4. Избавляемся от дубликатов.

**Условие.** В данном упражнении вам предстоит разработать программу, в которой у  пользователя будет запрошен список слов, пока он не оставит строку ввода пустой. После этого на экране должны быть показаны слова, введенные пользователем, но без повторов, – каждое по одному разу. При этом
слова должны быть отображены в том же порядке, в  каком их вводили с клавиатуры. Например, если пользователь на запрос программы введет следующий список слов:
```
first
second
first
third
second
```
программа должна вывести:
```
first
second
third
```
"""

#Напишите свое решение
# Создаем пустой список для хранения слов
word_list = []

# Запрашиваем ввод слов у пользователя
while True:
    word = input("Введите слово (или оставьте строку ввода пустой, чтобы завершить): ")
    if not word:
        break  # Если введена пустая строка, завершаем ввод
    if word.isdigit():
        print("Ошибка: введена цифра. Вводите только слова.")
        continue  # Продолжаем цикл, чтобы ввести другое слово
    word_list.append(word)

# Создаем список для хранения уникальных слов
unique_words = []

# Перебираем список слов и добавляем уникальные слова в unique_words
for word in word_list:
    if word not in unique_words:
        unique_words.append(word)

# Выводим уникальные слова в том же порядке, в котором они были введены
for word in unique_words:
    print(word)

"""## Задача 5. Ниже и выше среднего.

**Условие.** Напишите программу, которая будет запрашивать у  пользователя числа, пока не будет введена пустая строка. Сначала на экран должно быть выведено среднее значение введенного ряда чисел, после этого друг за другом необходимо вывести список чисел ниже среднего, равных ему (если такие
найдутся) и выше среднего. Каждый список должен предваряться соответствующим заголовком.
"""

#Напишите свое решение

# Создаем пустой список для хранения введенных чисел
numbers = []

# Запрашиваем у пользователя числа до тех пор, пока не будет введена пустая строка
while True:
    user_input = input("Введите число (или пустую строку для завершения): ")
    if user_input == "":
        break  # Прерываем цикл, если пользователь ввел пустую строку
    try:
        number = float(user_input)
        numbers.append(number)
    except ValueError:
        print("Неверный формат числа. Попробуйте снова.")

# Проверяем, что введено хотя бы одно число
if len(numbers) == 0:
    print("Вы не ввели ни одного числа.")
else:
    # Вычисляем среднее значение введенных чисел
    average = sum(numbers) / len(numbers)
    print(f"Среднее значение: {average}")

    # Создаем списки для чисел ниже и выше среднего
    below_average = [num for num in numbers if num < average]
    above_average = [num for num in numbers if num > average]

    # Выводим списки чисел
    if below_average:
        print("Числа ниже среднего:")
        for num in below_average:
            print(num)
    else:
        print("Нет чисел ниже среднего.")

    if above_average:
        print("Числа выше среднего:")
        for num in above_average:
            print(num)
    else:
        print("Нет чисел выше среднего.")

"""## Задача 6. Решето Эратосфена.

**Условие.** Решето Эратосфена – алгоритм, изобретенный более 2000 лет назад и служащий для нахождения всех простых чисел от 2 до некоторого целого числа n. Ваше решение должно начинаться с предложения пользователю ввести число, до которого необходимо вывести простые числа. Описание этого алгоритма приведено ниже.
```
Выписываем все целые числа от 0 до заданной границы
Вычеркиваем 0 и 1 как непростые числа
Устанавливаем значение переменной p, равное 2
Пока p меньше указанного числа, делать
 Вычеркиваем все числа, кратные p, но не его само
 Устанавливаем значение p, равное следующему невычеркнутому числу
Выводим все числа, оставшиеся незачеркнутыми
```

Ценность данного алгоритма заключается в том, что на бумаге очень легко вычеркнуть все числа, кратные определенному. Для компьютера это также не самая сложная задача – с этим может прекрасно справиться инструкция for с третьим параметром, переданным функции range. Мы знаем, что вычеркнутые числа на листочке не являются простыми, но физически они никуда с листа не деваются и должны участвовать в дальнейшем алгоритме. Так что и в компьютерной симуляции не стоит «вычеркивать» элемент путем его удаления из списка – вместо этого лучше
будет присвоить ему значение 0. После завершения алгоритма все ненулевые числа в списке и будут простыми.
Напишите программу на Python, реализующую указанный выше алгоритм для отображения простых чисел в интервале от двух до значения, введенного пользователем. Если алгоритм будет реализован правильно, ваша программа справится с выводом всех простых чисел от двух до миллиона всего за пару секунд.

> **Примечание.** Приведенный в данном упражнении алгоритм поиска простых чисел, названный в честь Эратосфена, был далеко не единственным вкладом греческого математика в науку. Ему также приписывают вычисление длины окружности Земли
и градус наклона ее оси. Кроме того, с 235 г. до н. э. он служил хранителем знаменитой Александрийской библиотеки.
"""

#Напишите свое решение
def SieveOfEratosthenes(n):

# Создаем логический массив
     # "prime[0..n]" и инициализируем
     # все записи верны.
     # Значение в prime[i] будет
     # наконец-то быть ложным, если я есть
     # Не простое число, иначе верно.
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):

# Если prime[p] не
         # изменилось, то это простое число
        if (prime[p] == True):

            # Обновляем все кратные p
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1

    # печать
    for p in range(2, n+1):
        if prime[p]:
            print(p)


# опробование алгоритма
n = 20
print("Ниже приведены простые числа меньшего размера."),
print("чем или равно", n)
SieveOfEratosthenes(n)

"""## Задача 7. Эрудит.

**Условие.** В известной игре Эрудит (Scrabble) каждой букве соответствует определенное количество очков. Общая сумма очков, которую получает игрок,
составивший это слово, складывается из очков за каждую букву, входящую
в его состав. Чем более употребимой является буква в языке, тем меньше
очков начисляется за ее использование. Напишите программу, рассчитывающую и отображающую количество очков за собранное слово. Создайте словарь для хранения соответствий между буквами и очками и используйте его в своем решении.
Система очков в игре Эрудит:
  * 1  - A, E, I, L, N, O, R, S, T и U
  * 2  - D и G
  * 3  - B, C, M и P
  * 4  - F, H, V, W и Y
  * 5  - K
  * 8  - J и X
  * 10 - Q и Z
"""

#Напишите свое решение
# Создаем словарь с соответствиями букв и очков
letter_scores = {
    'A': 1, 'E': 1, 'I': 1, 'L': 1, 'N': 1, 'O': 1, 'R': 1, 'S': 1, 'T': 1, 'U': 1,
    'D': 2, 'G': 2,
    'B': 3, 'C': 3, 'M': 3, 'P': 3,
    'F': 4, 'H': 4, 'V': 4, 'W': 4, 'Y': 4,
    'K': 5,
    'J': 8, 'X': 8,
    'Q': 10, 'Z': 10
}

# Функция для подсчета очков за слово
def calculate_word_score(word):
    score = 0
    for letter in word:
        letter = letter.upper()  # Преобразуем букву в верхний регистр, чтобы быть уверенными, что она соответствует ключам в словаре
        if letter in letter_scores:
            score += letter_scores[letter]
        else:
            print(f"Буква '{letter}' не найдена в словаре баллов и будет проигнорирована.")
    return score

# Запрашиваем у пользователя ввод слова
word = input("Введите слово: ")

# Рассчитываем и выводим количество очков за слово
score = calculate_word_score(word)
print(f"За слово '{word}' начислено {score} очков.")
